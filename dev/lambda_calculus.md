# 함수로 어떻게 프로그래밍하나요?

2018-11-29 토드 지식공유회 세션

## Introduction

* 좋은 프로그램이란 어떤 것일까?
    * 추상화 : 높은 표현력 (Composability)
    * 유연성 : 수정하기 쉬운가? 유지보수하기 좋은가?
* 코드를 짜는 것 = 도메인 언어를 만드는 것 (추상화된 언어)
* Simple vs Easy
    * Simple
        * 단순하다 : 조합해서 사용하기 좋은가?
        * 단순하다는 것이 가독성이 높다는 것은 아니다
        * ex) (--> users (filter developer?) (map :age) (reduce +))
    * Easy
        * ex) sumAgeForDevelopers(users)
        * Easy 한 함수를 만드는 것이 다는 아니다!
* 람다 함수는 Simple


## 상태, 조건, 반복으로 어떻게 프로그래밍 하나요?

* 튜링 머신과 튜링 완전
    * 튜링 머신은 범용 계산기를 만들 수 있는 이론적 배경
    * 튜링 머신의 이론을 토대로 우리가 사용하는 언어들이 완성되었다
* 튜링 머신의 대안은 없나요?
    * 람대 대수와 튜링 완전

## 람다 대수가 뭔가요?

* 프로그래밍 언어에서 first-class 함수와 함수를 처리하는 방식과 비슷하다
    * 따라서 first-class 함수를 지원하는 언어라면 람다 대수를 거의 활용할 수 있다
    * normal order (lazy evaluation) 으로 함수를 처리하는 언어는 람다 대수와 거의 똑같이 활용할 수 있다 (Haskell, R, ...)

## 함수로 어떻게 프로그래밍 하나요? : 람다 대수

* 람다 대수에는 두 가지 규칙만 존재한다
    * 1 : alpha-conversion
        * 인자만 바꾸는 것은 람다 식에 영향을 미치지 않는다 (기호를 치환할 수 있다)
            * `L x . x == L y . y`
            * `L x . x != L x . y`
    * 2 : beta-reduction
        * 인자를 반영해서 더 간단한 식으로 풀어낼 수 있다
        * `(L x . x) y = y`
            * 베타 리덕션으로 원래의 람다식을 풀어내면 (=evaluate) y가 된다
        * 인자를 넘길 수 없게 되면 beta-reduction이 불가해진다
* 나머지는 두 규칙을 어떻게 활용하는가에 대한 문제

### 숫자 연산

* 먼저 숫자부터 만들어야 한다 (람다 표현식에는 숫자를 표현하는 기호체계가 없기 때문)
    * L s z . z 는 0
    * L s z . s z 는 1
    * L s z . s (s z) 는 2
    * L s z . s (s (s z)) 는 3
    * ...
* 더하기 람다식
    * L x y . ( L s z . (x s (y s z)))
    * + 1 2
        * 규칙들을 적용하다보면 계산을 통해 3이라는 것을 확인할 수 있다

### 참거짓 람다식

* L t f . t = true
* L t f . f = false

### 조건문 람다식

* L b t f . b t f
    * if-else

### 반복문 람다식

* f = L x . f x 
    * 불가능. 람다대수에서는 이름을 붙일 수 없다
* 그래서 특별한 수식이 필요하다 : Y combinator (미국의 투자회사....??)
    * Y = L y . ( L x . y ( x x )) ( L x . y ( x x ))
        * Y f = f y f
    * 어떤 함수를 무한대로 증식할 수 있는 람다식 (무한 루프를 이론적으로 표현)
* Fixed-point combinator

## 그래서 함수로 어떻게 프로그래밍 하나요?

* 람다 대수는 튜링완전하기 때문에 이론적으로는 람다(first-class 함수)로 모든 계산이 가능하다
* 언어 차원에서는 편의를 위해 다양한 기능을 구현하여 제공